applyThiessenWeights <- function(X,thiessen_wgs,centroids)
{
    #### X is a spacetime obj
    #### thiessen_wgs is a data.frame
    ####      $SubbasinID is the subbasin id corresponding to the ids given in centroids
    ####      $thiessenID is the id of the observation station nearby which must be present in the spacetime dataframe X
    ####      $weights are the weights given by thiessen_weights.R
    
    spObj <- centroids[0,]
    st0 <- matrix()
    st0 <- st0[0]
    
    for(j in subbas@data$SubbasinID)
    {
        weights <- thiessen_wgs[thiessen_wgs$SubbasinID==j,]
        Xi <- matrix()
        Xi <- Xi[0]
        for(k in seq(1,length(weights$weights)))
        {
            Xi <- cbind(Xi,as.matrix(X[as.character(weights$thiessenID[k])]$values*weights$weights[k],ncol=1))
        }
        spObj <- spRbind(spObj,centroids[centroids@data$ids==j,])
        st0 <- cbind(st0,as.matrix(rowSums(Xi),ncol=1))
    }
    
    Xsubbas <- STFDF(sp=spObj,time=X@time,data=data.frame(values=matrix(t(st0),ncol=1)))
    return(Xsubbas)

}





genericplot <- function(x1,x2=NULL)
    {
        XDF_1<- data.frame(Date=as.POSIXct(time(x1)),value=coredata(x1))
        try(XDF_2<- data.frame(Date=as.POSIXct(time(x2)),value=coredata(x2)))
        colnames(XDF_1) <- c("Date",colnames(x1))
        try(colnames(XDF_2)[2] <- c("Date",colnames(x2)))
        XMelt <- melt(XDF_1,"Date")
        try(XMelt <- rbind(XMelt,melt(XDF_2,"Date")))
        
        if(Xname=="P")
            {
                q <- quantile(XMelt$value,na.rm=TRUE,seq(0,1,0.1))
                upper.fence <- q[11] + (q[11]-q[10])
                lower.fence <- 0
            } else
                {
                    upper.fence <- quantile(XMelt$value,na.rm=TRUE)[4] + 4*IQR(XMelt$value,na.rm=TRUE)
                    lower.fence <- quantile(XMelt$value,na.rm=TRUE)[2] - 3*IQR(XMelt$value,na.rm=TRUE)
                }
        ggplot(XMelt,aes(x=Date,y=value,group=variable,color=variable) ) +
            geom_line(size=0.6) + scale_color_manual(values=c("red", "blue","gray"))  +
#            scale_x_datetime(breaks=date_breaks(datebr), labels=date_format(datefmt)) +
            coord_cartesian(ylim=c(lower.fence, upper.fence)) +
            labs(x="Date",y=paste0(tit," ",uns)) +
            theme(text = element_text(size=8), axis.text.x = element_text(angle=90, vjust=1),legend.position="top")
                                        #                            ggtitle(paste0(Xname," in location ",location))
    }

genericplot_nlines <- function(x1)
    {
        colnames(x1) <- c("Date",colnames(x1[,2:ncol(x1)]))
        XDF_1 <- x1
        XMelt <- melt(XDF_1,"Date")
        
        if(Xname=="P")
            {
                q <- quantile(XMelt$value,na.rm=TRUE,seq(0,1,0.1))
                upper.fence <- q[11] + (q[11]-q[10])
                lower.fence <- 0
            } else
                {
                    upper.fence <- quantile(XMelt$value,na.rm=TRUE)[4] + 4*IQR(XMelt$value,na.rm=TRUE)
                    lower.fence <- quantile(XMelt$value,na.rm=TRUE)[2] - 3*IQR(XMelt$value,na.rm=TRUE)
                }
        ggplot(XMelt,aes(x=Date,y=value,group=variable,color=variable) ) +
            geom_line(size=0.6) + #scale_color_manual(values=c("red", "blue","gray"))  +
#            scale_x_datetime(breaks=date_breaks(datebr), labels=date_format(datefmt)) +
            coord_cartesian(ylim=c(lower.fence, upper.fence)) +
            labs(x="Date",y=paste0(tit," ",uns)) +
            theme(text = element_text(size=8), axis.text.x = element_text(angle=90, vjust=1),legend.position="top")
                                        #                            ggtitle(paste0(Xname," in location ",location))
    }

barplot_nbars <- function(x1)
    {
        colnames(x1) <- c("Date",colnames(x1[,2:ncol(x1)]))
        XDF_1 <- x1
        XMelt <- melt(XDF_1,"Date")
        
        ggplot(XMelt,aes(x=Date,y=value,fill=variable) ) +
            geom_bar(stat="identity",position=position_dodge())
                           
    }



fillGapsHourly <- function(tsObj)
    {
        require(xts)
        tsFull <- seq(time(first(tsObj)),time(last(tsObj)),by="hour")
        tsFilled <- merge(tsObj,tsFull,join="right")
        tsFilled <- na.approx(tsFilled)
        colnames(tsFilled) <- colnames(tsObj)
        return(tsFilled)
    }

fillGapsDaily <- function(tsObj)
    {
        require(xts)
        tsFull <- seq(time(first(tsObj)),time(last(tsObj)),by="day")
        
        tsFilled <- merge(tsObj,tsFull,join="right")
        tsFilled <- na.approx(tsFilled)
        colnames(tsFilled) <- colnames(tsObj)
        return(tsFilled)
    }

apply.months <- function(xtsObj,months,aggrFun="mean",na.rm=TRUE)
{
        #xtsObj is the time series to aggregate
    #require(quantmod)
    return(apply.yearly(xtsObj[.indexmon(xtsObj) %in% (months-1)],aggrFun,na.rm=TRUE))
}


aggrMonth <- function(stObjmon,month,aggrFun="sum")
    {
        ###mean precipitation for a given month in all stations.
        SP <- stObjmon[,.indexmon(stObjmon@time) %in% (month-1)]
        x <- as(SP, "xts")
        x <- apply(x, 2, aggrFun, na.rm=TRUE)
        return(SpatialPointsDataFrame(coords=coordinates(stObjmon@sp),data=data.frame(values=x),proj4string=CRS(proj4string(stObjmon@sp))))
    }        

aggrMonths.yearly <- function(stObj,months,aggrFun="mean")
{
    x <- aggregate(stObj[,.indexmon(stObj@time) %in% (months-1)],by="year",FUN=aggrFun)
    return(x)
}

interp_grid <- function(gridObj,spPointsObj)
    {
        interp <- idw(values ~ 1, locations=spPointsObj, newdata=gridObj,idp=10)
        colnames(interp@data) <- c("values","nothing")
        interp@data <- data.frame(values=interp@data$values)
        return(interp)
    }



fitPlaneToPoints <- function(spObj) {
                                        #prepare the data for the regression model
    Z <- spObj@data$values
    Y <- as.numeric(coordinates(spObj)[,2])
    X <- as.numeric(coordinates(spObj)[,1])
    dat <- data.frame(X=X,Y=Y,Z=Z )
    f.1 <- as.formula(Z ~ X + Y)
    
                                        # Run the regression model
    lm.1    <- lm( f.1, data=dat)
    return(lm.1)                                        #summary(lm.1)
}

SlopeDirection <- function(lm.1)
{
                                        #calculate the direction of the slope on the x,y axis (in degrees)
    direction <- atan(lm.1$coefficients[3]/lm.1$coefficients[2])
    if(direction>pi)
    {
        direction=direction-pi
    }
    return(direction)
}


Slope <- function(lm.1)
{
    x <- lm.1$coefficients[2]
    y <- lm.1$coefficients[3]
    z <- lm.1$coefficients[1]
    n <- (x^2+y^2+z^2)^0.5
    alph <- acos(z/n)
    return(tan(alph))
}





